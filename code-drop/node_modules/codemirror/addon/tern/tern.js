(function() {
  "use strict";

  CodeMirror.getURL = function(url, c) {
    var xhr = new XMLHttpRequest();
    xhr.open("get", url, true);
    xhr.send();
    xhr.onreadystatechange = function() {
      if (xhr.readyState != 4) return;
      if (xhr.status < 400) return c(null, xhr.responseText);
      var e = new Error(xhr.responseText || "No response");
      e.status = xhr.status;
      c(e);
    };
  };

  CodeMirror.TernServer = function(options) {
    var self = this;
    this.options = options || {};
    var plugins = this.options.plugins || {};
    if (!plugins.doc_comment) plugins.doc_comment = true;
    this.server = new tern.Server({
      getFile: function(name, c) { return getFile(self, name, c); },
      async: true,
      defs: this.options.defs || [],
      plugins: plugins
    });
    this.docs = Object.create(null);
    this.trackChange = function(doc, change) { trackChange(self, doc, change); };
  };

  CodeMirror.TernServer.prototype = {
    addDoc: function(name, doc) {
      this.server.addFile(name, doc.getValue());
      CodeMirror.on(doc, "change", this.trackChange);
      return this.docs[name] = {doc: doc, name: name, changed: null};
    },

    delDoc: function(name) {
      var found = this.docs[name];
      if (!found) return;
      CodeMirror.on(found.doc, "change", this.trackChange);
      delete this.docs[name];
      this.server.delFile(name);
    },

    complete: function(cm) {
      var self = this;
      CodeMirror.showHint(cm, function(cm, c) { return hint(self, cm, c); }, {async: true});
    }
  };

  var Pos = CodeMirror.Pos;
  var cls = "CodeMirror-Tern-";
  var bigDoc = 250;

  function getFile(ts, name, c) {
    var buf = ts.docs[name];
    if (buf)
      c(buf.doc.getValue());
    else if (ts.options.getFile)
      ts.options.getFile(name, c);
    else
      c(null);
  }

  function showError(ts, cm, string) {
    if (ts.options.showError)
      return ts.options.showError(cm, string);

    var tip = makeTooltip(cm.cursorCoords(null, "window"), string);
    function clear() {
      if (!tip.parentNode) return;
      cm.off("cursorActivity", clear);
      remove(tip);
    }
    setTimeout(clear, 2000);
  }

  function findDoc(ts, doc, name) {
    for (var name in ts.docs) {
      var cur = ts.docs[name];
      if (cur.doc == doc) return cur;
    }
    if (!name) for (var i = 0;; ++i) {
      var n = "[doc" + (i || "") + "]";
      if (!ts.docs[n]) { name = n; break; }
    }
    return ts.addDoc(n, doc);
  }

  function trackChange(ts, doc, change) {
    var data = findDoc(ts, doc);
    // FIXME cache invalidation goes here

    var changed = data.changed;
    if (changed == null)
      data.changed = changed = {from: change.from.line, to: change.from.line};
    var end = change.from.line + (change.text.length - 1);
    if (change.from.line < changed.to) changed.to = changed.to - (change.to.line - end);
    if (end >= changed.to) changed.to = end + 1;
    if (changed.from > change.from.line) changed.from = change.from.line;

    if (doc.lineCount() > bigDoc && change.to - changed.from > 100) setTimeout(function() {
      if (data.changed && data.changed.to - data.changed.from > 100) sendDoc(ts, data);
    }, 200);
  }

  function sendDoc(ts, doc) {
    ts.server.request({files: [{type: "full", name: doc.name, text: doc.doc.getValue()}]}, function(error) {
      if (error) console.error(error);
      else doc.changed = null;
    });
  }

  function makeTooltip(where, text) {
    var node = document.createElement("div");
    node.appendChild(document.createTextNode(text));
    node.className = cls + "tooltip";
    node.style.left = (where.right + window.pageXOffset) + "px";
    node.style.top = (where.top + window.pageYOffset) + "px";
    document.body.appendChild(node);
    return node;
  }

  function remove(node) {
    var p = node && node.parentNode;
    if (p) p.removeChild(node);
  }

  function typeToIcon(type) {
    var suffix;
    if (type == "?") suffix = "unknown";
    else if (type == "number" || type == "string" || type == "bool") suffix = type;
    else if (/^fn\(/.test(type)) suffix = "fn";
    else if (/^\[/.test(type)) suffix = "array";
    else suffix = "object";
    return cls + "completion " + cls + "completion-" + suffix;
  }

  function hint(ts, cm, c) {
    var doc = findDoc(ts, cm.getDoc());
    var req = buildRequest(ts, doc, {type: "completions", types: true, docs: true});

    ts.server.request(req, function(error, data) {
      if (error) return showError(cm, error);
      var completions = [], after = "";
      var from = data.start, to = data.end;
      if (cm.getRange(Pos(from.line, from.ch - 2), from) == "[\"" &&
          cm.getRange(to, Pos(to.line, to.ch + 2)) != "\"]")
        after = "\"]";

      for (var i = 0; i < data.completions.length; ++i) {
        var completion = data.completions[i], className = typeToIcon(completion.type);
        if (data.guess) className += " " + cls + "guess";
        completions.push({text: completion.name + after,
                          displayText: completion.name,
                          className: className,
                          doc: completion.doc});
      }

      var obj = {from: from, to: to, list: completions};
      var tooltip = null;
      CodeMirror.on(obj, "close", function() { remove(tooltip); });
      CodeMirror.on(obj, "select", function(cur, node) {
        remove(tooltip);
        if (cur.doc) tooltip = makeTooltip({
          top: node.getBoundingClientRect().top,
          right: node.parentNode.getBoundingClientRect().right
        }, cur.doc);
      });
      c(obj);
    });
  }

  function buildRequest(ts, doc, query, allowFragments) {
    var files = [], offsetLines = 0;
    if (typeof query == "string") query = {type: query};
    query.lineCharPositions = true;
    if (query.end == null) {
      query.end = doc.doc.getCursor("end");
      if (doc.doc.somethingSelected())
        query.start = doc.doc.getCursor("start");
    }
    var startPos = query.start || query.end;

    if (doc.changed) {
      if (doc.doc.lineCount() > bigDoc && allowFragments !== false &&
          doc.changed.to - doc.changed.from < 100 &&
          doc.changed.from <= startPos.line && doc.changed.to > query.end.line) {
        files.push(getFragmentAround(doc, startPos, query.end));
        query.file = "#0";
        var offsetLines = files[0].offsetLines;
        if (query.start != null) query.start = incLine(-offsetLines, query.start);
        query.end = incLine(-offsetLines, query.end);
      } else {
        files.push({type: "full",
                    name: doc.name,
                    text: doc.doc.getValue()});
        query.file = doc.name;
        doc.changed = null;
      }
    } else {
      query.file = doc.name;
    }
    for (var name in ts.docs) {
      var cur = ts.docs[name];
      if (cur.changed && cur != doc) {
        files.push({type: "full", name: cur.name, text: cur.doc.getValue()});
        cur.changed = null;
      }
    }

    return {query: query, files: files};
  }

  function getFragmentAround(data, start, end) {
    var doc = data.doc;
    var minIndent = null, minLine = null, endLine, tabSize = doc.getOption("tabSize");
    for (var p = start.line - 1, min = Math.max(0, p - 50); p >= min; --p) {
      var line = doc.getLine(p), fn = line.search(/\bfunction\b/);
      if (fn < 0) continue;
      var indent = CodeMirror.countColumn(line, null, tabSize);
      if (minIndent != null && minIndent <= indent) continue;
      minIndent = indent;
      minLine = p;
    }
    if (minLine == null) minLine = min;
    var max = Math.min(doc.lastLine(), end.line + 20);
    if (minIndent == null || minIndent == CodeMirror.countColumn(doc.getLine(start.line), null, tabSize))
      endLine = max;
    else for (endLine = end.line + 1; endLine < max; ++endLine) {
      var indent = CodeMirror.countColumn(doc.getLine(endLine), null, tabSize);
      if (indent <= minIndent) break;
    }
    var from = Pos(minLine, 0);

    return {type: "part",
            name: data.name,
            offsetLines: from.line,
            text: doc.getRange(from, Pos(endLine, 0))};
  }
  window.gfa = getFragmentAround;
})();
