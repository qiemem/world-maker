var http = require("http"), url = require("url"), querystring = require("querystring"), fs = require("fs");
var Mold = require("mold");

var index = Mold.bake(fs.readFileSync("index.html", "utf8"));

var result;
try {
  var resultData = JSON.parse(fs.readFileSync("result.json", "utf8"));
  result = {time: require("dateformat")(resultData.time, "yyyy-mm-dd HH:MM"),
            list: resultData.list};
} catch(e) {}

require("http").createServer(function(req, resp) {
  var target = url.parse(req.url);
  if (req.method == "POST") {
    var body = "";
    req.on("data", function (data) { body += data; });
    req.on("end", function() {
      var data = querystring.parse(body);
      if (data.email && data.editor) {
        logVote(data.email, data.editor);
        showPage(resp, true);
      } else showPage(resp);
    });
  } else showPage(resp);
}).listen(8112);

function showPage(resp, voted) {
  resp.writeHead(200, {"content-type": "text/html"});
  resp.end(index({
    voted: voted,
    editors: editors,
    result: result
  }));
}

// Data management

var fileName = "transactionlog.txt";
var log = [], text, editors = ["Sublime Text 2", "TextMate"], editorsSorted = true;

var editorBlacklist = ["vim", "emacs", "sublime text 2/3"];
function addEditor(name) {
  var low = name.toLowerCase();
  if (editorBlacklist.indexOf(low) >= 0) return;
  for (var i = 0; i < editors.length; ++i)
    if (editors[i].toLowerCase() == low) return;
  return editors.push(name);
}

try { text = fs.readFileSync(fileName, "utf8").split("\n"); }
catch(e) {}

if (text) for (var i = 0; i < text.length; ++i) {
  if (!text[i]) continue;
  var entry = JSON.parse(text[i]);
  log.push(entry);
  addEditor(entry.editor);
}
editors.sort();

function logVote(email, editor) {
  var obj = {email: email, editor: editor};
  fs.appendFileSync(fileName, JSON.stringify(obj) + "\n", "utf8");
  log.push(obj);
  if (addEditor(editor)) editors.sort();
}
